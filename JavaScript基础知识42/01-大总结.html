<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /* 
        第一、关于this指向
        1、函数外部this指向window
        2、普通函数,例如直接调用fn() ---此时this指向window
        3、对象来调用,例子 obj.demo()---看点 . 点前面是谁this就指向谁--此时的this指向obj
        总结：this--是动态的，我们还可以通过call()和apply来改变this指向

        第二、通过构造函数--引出原型prototype
        我们在工作里面属性放到构造函数身上，方法都放到原型上
        目标是为了节省内存，实现数据共享
        总结：我们以后属性放到构造函数身上，方法都放到原型上

        第三、经典的原创三句话
        1、每一个构造函数都有一个prototype属性，指向他的原型对象
        2、每一个实例化对象都有一个__proto__属性,指向他的所属类原型对象
        3、每一个原型对象都有个 constructor 属性，指向构造函数本身

        第四、获取原型对象的方法
        1、构造函数.prototype
        2、实例化对象.__proto__
        3、Object.getPrototypeOf(per1实例化对象)

        第五、in和hasOwnProperty的区别
        in--检测对象中的属性和方法（不仅能检测私有的还能检测公有的）---私有的是自己身上的，公有的原型身上的，如果有这个属性返回true，反之返回false
        hasOwnProperty：检测对象中的属性和方法（只能检测私有的，不能检测公有的） ---原型上的属性和方法他是检测不到的，能检测自己身上的。 同理：检测到了就返回true，反之检测不到返回false

        第六、如果有很多个方法---给原型指向一个{}，千万不要忘记修改指向 constructor:Person

        第七、建议大家都去画画--原型图就可以了

        第八、instanceof和isPrototypeOf关键字
        instanceof 找父类---判断某个对象是否是指定对象的原型对象，找到了返回true，反之返回false
        isPrototypeOf--同理--找父类--判断当前对象是否是指定类型，如果是返回true，反之返回false

        第九、混入式继承和原型式继承
        1、混入式继承：问题 存在数据共享，共享了同一个地址，修改其中一个另外一个也会被修改
        2、原型式继承：Person.prototype = Animal.prototype 问题 存在数据共享，共享了同一个地址，修改其中一个另外一个也会被修改
        
        第十、原型上添加方法：直接修改了底层--这样修改会会降低搜索效率

        第十一、安全的扩展内置对象
        1、提供一个构造函数
        2、在这个构造函数身上设置原型对象

        第十二、创建对象
        1、字面量创建对象的方式
        2、内置的构造函数创建对象
        3、工厂模式
        4、自定义构造函数方式
        5、Object.create : 特点：可以创建一个没有原型链的对象--查询搜索数据更快
        6、Object.assign:将多个对象合并到一起，合并对象如果重名会覆盖，替换。

        第十三、继承
        1、混入式继承
        2、原型式继承 Person.prototype = Animal.prototype
        3、原型链继承 Student.prototype = new Person()
        4、借用构造函数继承 （call继承、经典继承）--语法 构造函数.call(当前对象,参数,参数...)
        5、组合继承 （原型链继承 + 借用构造函数继承）

        第十四、call()和apply()
        1、借用其他对象的方法
        2、并且改变this
        特点:看call(第一个参数)  传递的第一个参数是谁，this就指向谁
        总结：如果不传递多个参数，call()和apply()是一样的
        如果传递了多个参数 包含两个和两个以上，call()后面可以任意，apply()必须是数组
        他们都在Function的原型上

        第十五、基本包装类型
        String、Number、Boolean--- 我们的基本包装类型可以调用属性和方法

        第十六、（）语法 就是为了json铺垫 ({"name":"zs"})--总结：我们拿到json数据可以直接加()变成对象来使用。

        第十七、Object的静态对象
          1、length---长度、形参的个数
          2、name --名字
          3、Object.assign:将多个对象合并到一起，合并对象如果重名会覆盖，替换。--创建对象的一种方式
          4、Object.create()---创建对象的一种方式
          5、is 判断参数是否相等等同于 === 但是有两个特殊 
          总结 0 和 - 0 、NaN 和 NaN
          6、Object.getOwnPropertyDescriptor: 获取当前对象总指定属性的描述对象 
        */
    </script>
</body>
</html>